Рассмотрим код

### JS
```js
var array = Array(0);
var index = 0;

const append = (item) => {
    var n = array.length;
    if (index >= n) {
        const temp = Array(n === 0 ? 1 : 2 * n);
        for (let i = 0; i < index; i++) {
            temp[i] = array[i];
        }
        array = temp;
    }
    array[index++] = item;
}
```

### Java
```java
static int[] array = new int[0];
static int index = 0;

static void append(int item) {
    int n = array.length;
    if (index >= n) {
        int[] temp = new int[n == 0 ? 1 : 2 * n];
        for (int i = 0; i < n; i++) {
            temp[i] = array[i];
        }
        array = temp;
    }
    array[index++] = item;
}
```

### C#
```csharp
int[] array = new int[0];
int index = 0;

void Append(int item)
{
    int n = array.Length;
    if (index >= n)
    {
        int[] temp = new int[n == 0 ? 1 : 2 * n];
        for (int i = 0; i < index; i++)
        {
            temp[i] = array[i];
        }
        array = temp;
    }
    array[index++] = item;
}
```

### Python
```python
array = []
index = 0

def append(item):
    global array, index
    n = len(array)
    if index >= n:
        temp = [0] * (1 if n == 0 else 2 * n)
        for i in range(index):
            temp[i] = array[i]
        array = temp
    array[index] = item
    index += 1
```

## Вставка элементов в динамический массив

### Процесс вставки

Предположим, что у нас есть динамический массив, который удваивает свой размер каждый раз, когда он заполняется. Начнём с массива размером 1 и будем вставлять элементы от 0 до 16.

### Таблица вставок

| Элемент | Индекс | Размер массива | Операции копирования | Операция `array[index++] = item;` |
|:-------:|:------:|:--------------:|:--------------------:|:---------------------------------:|
|    0    |   0    |       1        |          0           |                 1                 |
|    1    |   1    |       2        |          1           |                 1                 |
|    2    |   2    |       4        |          2           |                 1                 |
|    3    |   3    |       4        |          0           |                 1                 |
|    4    |   4    |       8        |          4           |                 1                 |
|    5    |   5    |       8        |          0           |                 1                 |
|    6    |   6    |       8        |          0           |                 1                 |
|    7    |   7    |       8        |          0           |                 1                 |
|    8    |   8    |       16       |          8           |                 1                 |
|    9    |   9    |       16       |          0           |                 1                 |
|   10    |   10   |       16       |          0           |                 1                 |
|   11    |   11   |       16       |          0           |                 1                 |
|   12    |   12   |       16       |          0           |                 1                 |
|   13    |   13   |       16       |          0           |                 1                 |
|   14    |   14   |       16       |          0           |                 1                 |
|   15    |   15   |       16       |          0           |                 1                 |
|   16    |   16   |       32       |          16          |                 1                 |

Не забываем, что на каждом этапе у нас есть операция вставки элемента `array[index++] = item;`

### Амортизационная сложность

Амортизационная сложность вставки элемента в динамический массив определяется как средняя стоимость вставки одного элемента, учитывая все операции копирования, которые происходят при увеличении размера массива.

#### Анализ

1. **Вставка без увеличения размера**: O(1)
2. **Вставка с увеличением размера**: O(n), где n — текущий размер массива

При каждом увеличении размера массива происходит копирование всех элементов в новый массив. Однако, если рассмотреть все вставки, то можно заметить, что количество операций копирования распределяется по всем вставкам.

#### Пример

- Вставка на 0-ю позицию: 0 операция копирования
- Вставка на 1-ю позицию: 1 операции копирования
- Вставка на 2-го позицию: 2 операции копирования
- Вставка на 3-ю позицию: 0 операции копирования
- Вставка на 4-ю позицию: 4 операции копирования
- Вставка на 5-ю, 6-ю, 7-ю позицию: 0 операции копирования
- Вставка на 8-ю позицию: 8 операций копирования
- Вставка на 9-ю, ... 15-ю позицию: 0 операции копирования
- Вставка на 16-ю позицию: 16 операций копирования
и т. д.

### Общий случай

Для вставки $N$-го элемента, где $N$ — степень двойки ($N = 2^k$), потребуется $2^k$ операций копирования.

### Формула для общего случая

Рассмотрим последовательность вставок и количество операций копирования:

- Вставка на 0-ю позицию: 0 операция копирования
- Вставка на 1-ю позицию: $2^0$ операции копирования
- Вставка на 2-го позицию: $2^1$ операции копирования
- Вставка на 3-ю позицию: 0 операции копирования
- Вставка на 4-ю позицию: $2^2$ операции копирования
- Вставка на 5-ю, 6-ю, 7-ю позицию: 0 операции копирования
- Вставка на 8-ю позицию: $2^3$ операций копирования
- Вставка на 9-ю, ..., 15-ю позицию: 0 операции копирования
- Вставка на 16-ю позицию: $2^4$ операций копирования
и т. д.

### Сумма операций копирования

Для $N$ элементов, где $N = 2^k$, суммарное количество операций копирования можно выразить как: 

$$2^0 + 2^1 + 2^2 + \ldots + 2^k$$
Можно записать коротко
$$\sum_{i=0}^{k} 2^i$$


Чтобы вычислить сумму, вспомним что такое геометрическая прогрессия и некоторые формулы
## Формулы геометрической прогрессии

Геометрическая прогрессия - это последовательность чисел, в которой каждый следующий член получается умножением предыдущего на одно и то же число, называемое знаменателем прогрессии.

### Основные понятия

- $b_1$ - первый член прогрессии
- $b_n$ - n-ый член прогрессии
- $q$ - знаменатель прогрессии
- $n$ - количество членов прогрессии
- $S_n$ - сумма первых n членов прогрессии

### Формулы

1. **n-ый член прогрессии:** $$b_n = b_1 \cdot q^{n-1}$$
2. **Сумма первых n членов прогрессии:**   $$S_n = \frac{b_1(q^n-1)}{q-1}, q \neq 1$$
### Пример

В нашем случае с динамическим массивом мы использовали геометрическую прогрессию со следующими параметрами:

- $b_1 = 1$ (первый член прогрессии)
- $q = 2$ (знаменатель прогрессии)
- $n = k+1$ (количество членов)

Сумма этой прогрессии:

$$ S_{n} = \frac{1(2^{k+1}-1)}{2-1} = 2^{k+1} - 1 $$

### Распишем
$$\sum_{i=0}^{k} 2^i = 2^0 + 2^1 + 2^2 + \ldots + 2^k = 2^{k+1} - 1$$ 

### Амортизационная сложность

Общее количество операций копирований: $2^{k+1} - 1$, к которым нужно добавить $N+1$ операцию `array[index++] = item`

Теперь, чтобы найти амортизационную сложность, нужно разделить суммарное количество операций на количество добавления элементов $N$:

$\text{Амортизационная сложность} = \frac{2^{k+1} - 1 + N + 1}{N}$

По одной из формул свойств степеней: $a^{n+m} = a^n \cdot a^m$ и $N = 2^k$, тогда получим:

$\text{Амортизационная сложность} = \frac{2^k \cdot 2^1 - 1 + N + 1}{N} = \frac{2 \cdot N + N}{N} = 3$

При больших $k$ (то есть при большом $N$), амортизационная сложность приближается к 3. 
Получается, количество операций добавления сводится примерно к трём операциям, то есть к $O(1)$

### Заключение

Таким образом, ~~математика программистам не нужна~~ вы можете забыть все выкладки, и запомнить только то, что **амортизационная сложность вставки элемента в динамический массив составляет $O(1)$. Это означает, что в среднем вставка одного элемента требует постоянное время, несмотря на то, что иногда требуется копирование всех элементов при увеличении размера массива**.
